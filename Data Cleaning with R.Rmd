---
title: "Data Cleaning with R"
author: "Simone Vito Lopes"
date: "`r Sys.Date()`"
output:
  word_document: default
  pdf_document: default
---

```{r,echo=FALSE, message=FALSE, results='hide',warning=FALSE} 
# Clean the workspace, plots and console
rm(list=ls())
if(!is.null(dev.list())) dev.off()
cat("\014")

#Numbers format
options(scipen=9)

# Configuring the working directory.
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '.../Data Cleaning with R')

# Install Libraries/Packages
if(!require(knitr)){install.packages("knitr")}
library("knitr")
if(!require(dplyr)){install.packages("dplyr")}
library(dplyr)
if(!require(zoo)){install.packages("zoo")}
library(zoo)
if(!require(tidyr)){install.packages("tidyr")}
library(tidyr)
if(!require(stringr)){install.packages("stringr")}
library(stringr)
if(!require(tidyverse)){install.packages("tidyverse")}
library(tidyverse)
if(!require(pastecs)){install.packages("pastecs")}
library("pastecs")
if(!require(lattice)){install.packages("lattice")}
library("lattice")
if(!require(corrgram)){install.packages("corrgram")}
library("corrgram")
if(!require(ggplot2)){install.packages("ggplot2")}
library(ggplot2)

```
# 1. Introduction: 

This dataset shows data about movies. It provides information about films and their performance. With this data, we can identify trends and whether each element contributes to the excellent performance of the film or not.\

Below, is an explanation of each column before analysis and data cleaning:\

**MOVIES**: This column contains the movie names or titles.\
**YEAR**: Represents the release year of each movie.\
**GENRE**: Contains the category or type of each film.\
**RATING**: This column contains the rating or score for each movie.\
**ONE-LINE**: Consists of the descriptions of each movie.\
**STARS**: This column contains the names of actors or actresses who appear in the movie.\
**VOTES**: Contains the number of ratings each film has received.\
**RunTime**: Logs the duration of each film, probably in minutes.\
**Gross**: Represents the total revenue generated by the film.\


# 2. Data Exploration
The tool used to analyze and clean the data is RStudio.\
For the Data Exploration part, I Loaded the file Movies.csv and identified the columns, structure and type of columns.\

*a. Load the dataset.*\
```{r}
# Loading a csv file
options(digits=5)
movies_dataset <- read.csv("Movies.csv", header = TRUE, sep = ",")
```

*b. Initial exploration of the dataset, such as checking the dimensions, previewing a few rows, and identifying the data types of each column.*\
```{r,echo=FALSE}
# Show the dimensions
cat("Movies dataset has", dim(movies_dataset)[1], "rows and", dim(movies_dataset)[2], 
    "columns.\n")

# Identifying the data types of each column
cat('Data types:\n')
str(movies_dataset)

# Previewing a few rows
head(movies_dataset,5)
```


# 3. Handling Missing Values

*a. Identifying columns with missing values.*\
```{r}

# Clearing '\n' characters from all columns
for (col in names(movies_dataset)) {
  movies_dataset[[col]] <- gsub("\n", "", movies_dataset[[col]])
}

# Looking for missing values
movies_dataset[movies_dataset == ""] <- NA
colSums(is.na(movies_dataset))

```

*b. Evaluating the extent of missing values in each column and decide on an appropriate strategy for handling them.*\
\
The strategy will depend on the number of NA values, I'm thinking in follow these steps.\
First, the Gross column will be deleted because have more than 95% of the missing values.\
Then I'll find movies that have more than one line, and if a line has value, I can use it to fill the NA's, as follows:\
   YEAR - Fill the column with NA using the year found.\
   GENRE - Fill the column with NA using the found genre.\
   RATING - Fill the column with NA using the average of all lines found.\
   STARS - Fill the column with NA using the found stars.\
   VOTES - Fill the column with NA using the average.\
   RunTime - Fill the column with NA using the value that appeared the most.\
After these searches, I will analyze again to see if the numbers have improved.\
Then I can delete the rows where the RATING, VOTES and RunTime columns have NA.\
I will do the analysis again to see if there are still NAs.\

*c. Start implement the chosen strategy.*\
```{r}
# Removing the column Gross because have more than 95% of the missing values.
movies_dataset <- movies_dataset[, -which(names(movies_dataset) == "Gross"), drop = FALSE]

# Clear leading and trailing whitespace in character-type columns
# Some columns have space at the beginning of the value, so I clean it to ensure that the space will not interfere with the result.
movies_dataset <- movies_dataset %>%
  mutate_if(is.character, trimws)


## I filled the columns with some reasonable data to decrease data loss.

# YEAR - Looking for values on the lines of the same movie.
# order by MOVIE and YEAR
movies_dataset <- movies_dataset[order(movies_dataset$MOVIES, movies_dataset$YEAR), ]

movies_dataset <- movies_dataset %>%
  group_by(MOVIES) %>%
  mutate(YEAR = if (any(!is.na(YEAR))) na.locf(YEAR) else YEAR)

# GENRE - Looking for values on the lines of the same movie.
# order by MOVIE, YEAR and GENRE
movies_dataset <- movies_dataset[order(movies_dataset$MOVIES, movies_dataset$YEAR, movies_dataset$GENRE), ]

movies_dataset <- movies_dataset %>%
  group_by(MOVIES) %>%
  mutate(GENRE = if (any(!is.na(GENRE))) na.locf(GENRE) else GENRE)

# STARS - Looking for values on the lines of the same movie.
# order by MOVIE and STARS
movies_dataset <- movies_dataset[order(movies_dataset$MOVIES, movies_dataset$STARS), ]

# Fills NA with the median.
movies_dataset <- movies_dataset %>%
  group_by(MOVIES) %>%
  fill(STARS)

# RATING - Looking for values on the lines of the same movie.
# order by MOVIE and RATING
movies_dataset <- movies_dataset[order(movies_dataset$MOVIES, movies_dataset$RATING), ]
# convert to numeric
movies_dataset$RATING <- as.numeric(movies_dataset$RATING)

# Fills NA with the median in the column RATING.
movies_dataset <- movies_dataset %>%
  group_by(MOVIES) %>%
  mutate(RATING = na.aggregate(RATING))

# round the value
movies_dataset$RATING <- round(movies_dataset$RATING, 1)

# RunTime - Looking for values on the lines of the same movie.
# order by MOVIE and RunTime
movies_dataset <- movies_dataset[order(movies_dataset$MOVIES, movies_dataset$RunTime), ]
# convert to numeric
movies_dataset$RunTime <- as.numeric(movies_dataset$RunTime)

# Function to find the mode (most frequent value)
find_mode <- function(x) {
  if (length(x) == 0) {
    return(NA) # Returns NA if the array is empty
  } else {
    tbl <- table(x, useNA = "always") # Count NA values
    mode_val <- as.numeric(names(tbl[tbl == max(tbl)]))
    if (length(mode_val) > 0) {
      return(mode_val[1])  # Select the first most frequent value in case of ties.
    } else {
      return(NA) # Returns NA if all values are NA
    }
  }
}


# Fills NA with the most frequent value per movie.
movies_dataset <- movies_dataset %>%
  group_by(MOVIES) %>%
  mutate(RunTime = ifelse(is.na(RunTime), find_mode(RunTime), RunTime))

# VOTES - Looking for values on the lines of the same movie.
movies_dataset <- movies_dataset[order(movies_dataset$MOVIES, movies_dataset$VOTES), ]
# remove commas
movies_dataset$VOTES <- gsub(",", "", movies_dataset$VOTES) 
# convert to numeric
movies_dataset$VOTES <- as.numeric(movies_dataset$VOTES)   

# Fills NA with the median.
movies_dataset <- movies_dataset %>%
  group_by(MOVIES) %>%
  mutate(VOTES = na.aggregate(VOTES))

colSums(is.na(movies_dataset))
cat("Movies dataset has", dim(movies_dataset)[1], "rows and", dim(movies_dataset)[2], 
    "columns.\n")


# I deleted the lines with the RATING, VOTES and RunTime columns filled with NA.
# These cells are the basis for performing numerous analyzes on this dataset. I understand that the line is irrelevant if there is no value in these columns.

# The command complete.cases return all data that don't have NA.
movies_dataset <- movies_dataset[complete.cases(movies_dataset[, c("RATING", "VOTES", "RunTime")]), ]

# Show the data information again to see if NA values still exist.
colSums(is.na(movies_dataset))
cat("Movies dataset has", dim(movies_dataset)[1], "rows and", dim(movies_dataset)[2], 
    "columns.\n")

# As we had only 7 NAs on GENRE and 24 on STARS, I filled the columns with the information "Unknown value" to avoid losing more data.
colunas_com_NA <- colnames(movies_dataset)[apply(is.na(movies_dataset), 2, any)]
movies_dataset[colunas_com_NA] <- lapply(movies_dataset[colunas_com_NA], function(x) ifelse(is.na(x), "Unknown value", x))

```

*d. Validating the changes made and ensuring that no missing values remain.*\
```{r}

# Verify the data information to see if NA values still exist.
colSums(is.na(movies_dataset))
cat("Movies dataset has", dim(movies_dataset)[1], "rows and", dim(movies_dataset)[2], 
    "columns.\n")

head(movies_dataset, 5) # The analysis was about the whole dataset, but I'm printing only 5 lines for demonstration. 

```

Steps
1. When I ran the head command to see the data, I saw many '\n' characters before the values, so I cleared those characters from all columns.
2. I looked for missing values. I found missing values on columns YEAR, GENRE, RATING, STARS, VOTES, RunTime, and Gross.
3. How I handdled each column is explain in part 3b.
  

# 4. Removing Duplicates

*a. Checking for duplicate rows in the dataset.*\
```{r}
# To identify duplicates, I used the duplicates command.
linhas_duplicadas <- duplicated(movies_dataset)
print(movies_dataset[linhas_duplicadas, ])
```

*b. Removing Duplicates.*\
```{r}
# I created a new dataset. Here I'm using the same name, with unique values.
movies_dataset <- unique(movies_dataset)
```

*c. Verifying if duplicate rows have been successfully removed.*\
```{r}
# Verify the duplicates again to be sure.
linhas_duplicadas <- duplicated(movies_dataset)
print(movies_dataset[linhas_duplicadas, ])
```

I first checked for duplicates using the duplicate() command, then removed the duplicates using the unique() command and checked again to make sure all duplicates were removed.\

# 5. Dealing with Inconsistent Data

*a. Identifying columns that contain inconsistent or erroneous data.*\
1. Column names are not standardized. \
2. The STARS column also contains director information.\
3. There are special characters in the data - column MOVIES. \
4. The YEAR column contains characters, not just numbers, sometimes just one year, sometimes two.\
5. Adjustment of column types and order.\

*b. Implementing necessary corrections to resolve inconsistencies.*\
```{r}
# 1. Column names are not standardized.
# Standardizing column names. To standardize the column names I will use the CamelCase technique.
# I changed the column name ONE.LINE to description.

colnames(movies_dataset) <- c("movies", "year", "genre", "rating", "description", "stars", "votes", "runTime")

```

```{r}
# 2. Separate column stars to director and stars

# stars to director and stars
split_column <- function(info) {
  parts <- strsplit(info, "\\|")
  if (length(parts[[1]]) == 2) {
    return(c(director = parts[[1]][1], stars = parts[[1]][2]))
  } else {
    return(c(director = NA, stars = parts[[1]][1]))
  }
}

movies_dataset[, c("director", "stars")] <- t(sapply(movies_dataset$stars, split_column))

# clean the names from value
movies_dataset$director <- gsub("Directors:", "", movies_dataset$director)
movies_dataset$director <- gsub("Director:", "", movies_dataset$director)
movies_dataset$stars <- gsub("Stars:", "", movies_dataset$stars)
movies_dataset$stars <- gsub("Star:", "", movies_dataset$stars)

# Set the columns NA after split as "Unknown value"
colunas_com_NA <- colnames(movies_dataset)[apply(is.na(movies_dataset), 2, any)]
movies_dataset[colunas_com_NA] <- lapply(movies_dataset[colunas_com_NA], function(x) ifelse(is.na(x), "Unknown value", x))

```

```{r}
# 3. Clean special characters on movies column.
clean_chars <- function(x) {
  x <- gsub("[^[:alnum:] :]", "", x)  # Removes all non-alphanumeric characters, spaces and ":"
  x <- gsub("\\s+", " ", x)          # Remove extra spaces and replace them with a single space.
  return(x)
}

movies_dataset$movies <- clean_chars(movies_dataset$movies)
colSums(is.na(movies_dataset))

```

```{r}
# 4. I will clean the charateres and create two columns initialYear, and finalYear

# year to initialYear, and finalYear
movies_dataset[c("initialYear", "finalYear")] <- do.call(rbind, strsplit(as.character(movies_dataset$year), "-|–"))

# Clears non-numeric characters
movies_dataset$initialYear <- as.numeric(gsub("[^0-9]", "", movies_dataset$initialYear))
movies_dataset$finalYear <- as.numeric(gsub("[^0-9]", "", movies_dataset$finalYear))

# If one of the columns is NA, it will be filled in with the year of the other column.
movies_dataset$initialYear <- ifelse(is.na(movies_dataset$initialYear), movies_dataset$finalYear, movies_dataset$initialYear)
movies_dataset$finalYear <- ifelse(is.na(movies_dataset$finalYear), movies_dataset$initialYear, movies_dataset$finalYear)

# Check if NA exists
rows_with_na <- subset(movies_dataset, is.na(initialYear) | is.na(finalYear))
print(rows_with_na)

#Adjustments in NA found
movies_dataset <- movies_dataset[order(movies_dataset$movies, movies_dataset$initialYear), ]

movies_dataset <- movies_dataset %>%
  group_by(movies) %>%
  mutate(
    initialYear = if (any(!is.na(initialYear))) na.locf(initialYear) else initialYear,
    finalYear = if (any(!is.na(finalYear))) na.locf(finalYear) else finalYear
  )

```

```{r, warning=FALSE}

# 5. Other adjustments, such as, order, clean spaces.

# Work with the column year.
movies_dataset <- movies_dataset[, -which(names(movies_dataset) == "year"), drop = FALSE]
movies_dataset <- movies_dataset[, -which(names(movies_dataset) == "finalYear"), drop = FALSE]
names(movies_dataset)[names(movies_dataset) == "initialYear"] <- "year"

# Order columns 
movies_dataset <- movies_dataset[, c("movies", "year", "genre", "description", "director", "stars", "rating", "votes", "runTime")]

# Clean the spaces
movies_dataset <- movies_dataset %>% 
  mutate_if(is.character, trimws)

# Type of column
movies_dataset$year <- as.character(movies_dataset$year)

```

*c. Below is a quick explanation of the changes made.*\

**1. Column names are not standardized.** \
To make it easier to understand the columns and have a naming pattern.\
**2. The STARS column also contains director information.**\
I separated the columns to better identify the directors and actors, a lot of people search for movies by the name of the director or actor, so I understand that the evaluations can also be influenced by these elements.\
**3. There are special characters in the data - column MOVIES.** \
I removed the special characters so as not to generate problems in future analyses.\
**4. The YEAR column contains characters, not just numbers, sometimes just one year, sometimes two.**\
The year column was a mess. I tried to clean all non-numeric characters and separate between the initial and final year, I saw that many films were without one or the other, so I decided to merge the two and gave priority to the initial year, so we were left with a year column that can contain the initial or final year of the film.\
**5. Adjustment of column types and order.**\
I put the columns in an order that makes more sense, with character types first and numbers after, for example. I cleaned the spaces that might still exist in the data. The dataset is simpler and easier to understand if it has a coherent order.\
I thought of facilitating the visualization and understanding of the data in the best possible way.\


# 6. Handling Outliers

*a. Identifying columns that may contain outliers.*\
Identify outliers in the runTime column. It's not normal for a movie or show with less than 20 minutes.\
```{r}

summary(movies_dataset[, c("rating", "votes", "runTime")])

```


*b. Visualizing the distributions of columns using plots.*\
```{r}
ggplot(data = movies_dataset, aes(x = "", y = runTime)) +
  geom_boxplot() +
  labs(title = "Boxplot - runTime", y = "runTime") +
  theme_minimal() +
  coord_flip()

ggplot(data = movies_dataset, aes(x = "", y = votes)) +
  geom_boxplot() +
  labs(title = "Boxplot - votes", y = "votes") +
  theme_minimal() +
  coord_flip()

densityplot( ~ movies_dataset$runTime, pch=6, main = 'DL_SVL')
densityplot( ~ movies_dataset$votes, pch=6, main = 'DL_SVL')
```


*c. Analyzing the outliers and deciding on an appropriate strategy for handling them.*\
In the runTime column, there are outliers both in the minimum and maximum values, in the graphs, the maximum values are clear, but I will eliminate all values above 400 and below 15 minutes.\
In the votes column also have outliers, I will remove the values above 1000000.


*d. Implementing the chosen strategy and validate the changes made.*\
```{r}
# Removing values below 15 and above 400 from column runTime.
movies_dataset <- subset(movies_dataset, runTime >= 15 & runTime <= 400)

# Removing values above 1000000 from column votes
movies_dataset <- subset(movies_dataset, votes <= 1000000)

```

I tried to understand which columns could have outliers and then generated the graphs to be more visual. Cleaning was a mix of what I analyzed in the data with my idea of what would be correct.\

# 7. Data Validation

*a. Additional checks or validations to ensure the overall quality of the dataset.*\
```{r}
# Show the dimensions
cat("Movies dataset has", dim(movies_dataset)[1], "rows and", dim(movies_dataset)[2], 
    "columns.\n")

# Identifying the data types of each column
summary(movies_dataset)

# Previewing a few rows
head(movies_dataset,5)

# Verify NA
movies_dataset$movies <- clean_chars(movies_dataset$movies)
colSums(is.na(movies_dataset))
```

```{r}
# Creating a new file with the changes made.
write_excel_csv(movies_dataset, file = "movies_dataset_cleaned.csv")

```

I searched again for the dimensions of the dataset. I checked the data and if NA's still appeared.\

# 8. Observations 

It's an exciting dataset, and it's exactly like that in real life; a very big job to be done to clean the data, especially if there is no validation at the time of inclusion by users.\

*If you open the cleaning dataset in Excel and the letter "é" is displayed as "√©", for example. Instead of opening directly, try importing the data. --> Go to: 'Data' --> Get the data 'From Text/CSV' and then select '65001:Unicode (UTF-8)'. This will match the encoding from R.*


# 9. Conclusion

Finally, the dataset provides a comprehensive view of diverse films, containing critical aspects that shed light on their performance and qualities. The collection comprises movie titles, release years, genres, and descriptions that provide insight into the diversity of movie topics and genres. The ratings and number of votes provide useful information regarding the reception and popularity of each film among the general public. Furthermore, including famous actors, actresses, and directors allows us to investigate the impact of casting decisions on a film's popularity.\
The dataset's cleanliness and coherence and well-structured and relevant column names make it more accessible and usable for data analysis and interpretation. Filmmakers and industry experts can use this dataset to make educated decisions, establish effective film strategies, and better understand the film industry's dynamic terrain.